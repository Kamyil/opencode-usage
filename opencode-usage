#!/usr/bin/env bash
set -euo pipefail

usage() {
	cat <<'EOF'
Usage: opencode-usage [options]

Summarize OpenCode usage for a given month from the SQLite DB.

Options:
  --db PATH                 Path to opencode.db (default: ~/.local/share/opencode/opencode.db)
  --month YYYY-MM           Month to report (default: current month)
  --category NAME:PATH      Assign project path prefix to category (repeatable)
  --default-category NAME   Bucket name for uncategorized paths (default: other)
  --top N                   Top projects to list per bucket (default: 5)
  --input-rate NUM          Cost per 1M input tokens
  --output-rate NUM         Cost per 1M output tokens
  --reasoning-rate NUM      Cost per 1M reasoning tokens (default: input-rate)
  --cache-read-rate NUM     Cost per 1M cache read tokens
  --cache-write-rate NUM    Cost per 1M cache write tokens
  --currency SYMBOL         Currency symbol for cost output (default: $)
  --todos                   Show todo/task completion statistics
  --pretty                  Pretty-print output with box drawing and bars
  --help                    Show this help

Examples:
  opencode-usage --category work:~/Work --category personal:~/Personal
  opencode-usage --month 2026-02 --category work:~/Work --category personal:~/Personal
  opencode-usage --category client:~/Clients --category hobby:~/Hobby
  opencode-usage --input-rate 5 --output-rate 15 --currency "$"
EOF
}

expand_path() {
	local value=$1
	case "$value" in
		"~") printf '%s' "$HOME" ;;
		"~/"*) printf '%s/%s' "$HOME" "${value:2}" ;;
		*) printf '%s' "$value" ;;
	esac
}

sql_escape() {
	local value=$1
	value=${value//\'/\'\'}
	printf '%s' "$value"
}

build_like_clause() {
	local clause=""
	local prefix
	for prefix in "$@"; do
		prefix=$(expand_path "$prefix")
		prefix=${prefix%/}
		if [[ -z "$prefix" ]]; then
			continue
		fi
		if [[ -n "$clause" ]]; then
			clause+=" or "
		fi
		clause+="worktree like '$(sql_escape "$prefix")%'"
	done
	if [[ -z "$clause" ]]; then
		clause="0"
	fi
	printf '%s' "$clause"
}

add_category_prefix() {
	local name=$1
	local prefix=$2
	if [[ -z "$name" || -z "$prefix" ]]; then
		return 1
	fi
	if [[ -z "${CATEGORY_PREFIXES[$name]+x}" ]]; then
		CATEGORY_PREFIXES[$name]=""
		CATEGORY_NAMES+=("$name")
	fi
	if [[ -n "${CATEGORY_PREFIXES[$name]}" ]]; then
		CATEGORY_PREFIXES[$name]+=$'\n'
	fi
	CATEGORY_PREFIXES[$name]+="$prefix"
}

category_clause() {
	local name=$1
	local value=${CATEGORY_PREFIXES[$name]-}
	local prefixes=()
	if [[ -n "$value" ]]; then
		readarray -t prefixes <<< "$value"
	fi
	build_like_clause "${prefixes[@]}"
}

format_table() {
	if command -v column >/dev/null 2>&1; then
		column -t -s $'\t'
	else
		cat
	fi
}

format_number() {
	local num=$1 int_part dec_part="" result="" i len
	if [[ "$num" =~ \. ]]; then
		int_part=${num%%.*}
		dec_part=${num#*.}
	else
		int_part=$num
	fi
	# Remove leading zeros/spaces but keep the number valid
	printf -v int_part '%d' "$int_part" 2>/dev/null || int_part=0
	# Handle negative numbers
	local sign=""
	if (( int_part < 0 )); then
		sign="-"
		int_part=$(( -int_part ))
	fi
	local s="$int_part"
	len=${#s}
	for (( i=0; i<len; i++ )); do
		if (( i > 0 && (len - i) % 3 == 0 )); then
			result+=","
		fi
		result+="${s:i:1}"
	done
	if [[ -n "$dec_part" ]]; then
		printf '%s%s.%s' "$sign" "$result" "$dec_part"
	else
		printf '%s%s' "$sign" "$result"
	fi
}

BAR_WIDTH=30

make_bar() {
	local pct=$1
	# Pure bash: multiply pct*BAR_WIDTH using integer math with 100x scaling
	# pct is like "45.23" — strip the dot to get integer hundredths
	local int_part=${pct%%.*}
	local dec_part=${pct#*.}
	# If no decimal point, dec_part equals int_part
	[[ "$dec_part" == "$pct" ]] && dec_part="0"
	# Pad or trim dec_part to exactly 2 digits
	dec_part="${dec_part}00"
	dec_part="${dec_part:0:2}"
	# pct_x100 = pct * 100 (e.g. 45.23 -> 4523)
	local pct_x100=$(( 10#$int_part * 100 + 10#$dec_part ))
	# filled = round(pct * BAR_WIDTH / 100) = round(pct_x100 * BAR_WIDTH / 10000)
	local filled=$(( (pct_x100 * BAR_WIDTH + 5000) / 10000 ))
	(( filled > BAR_WIDTH )) && filled=$BAR_WIDTH
	(( filled < 0 )) && filled=0
	local empty=$((BAR_WIDTH - filled))
	local bar=""
	for ((i = 0; i < filled; i++)); do bar+="█"; done
	for ((i = 0; i < empty; i++)); do bar+="░"; done
	printf '%s' "$bar"
}

BOLD=""
DIM=""
RESET=""
CYAN=""
GREEN=""
YELLOW=""
MAGENTA=""
WHITE=""

init_colors() {
	if [[ -t 1 ]]; then
		BOLD=$'\033[1m'
		DIM=$'\033[2m'
		RESET=$'\033[0m'
		CYAN=$'\033[36m'
		GREEN=$'\033[32m'
		YELLOW=$'\033[33m'
		MAGENTA=$'\033[35m'
		WHITE=$'\033[37m'
	fi
}

repeat_char() {
	local char=$1 count=$2 result=""
	for (( i=0; i<count; i++ )); do result+="$char"; done
	printf '%s' "$result"
}

box_top()    { printf '╭%s╮\n' "$(repeat_char '─' "$1")"; }
box_bottom() { printf '╰%s╯\n' "$(repeat_char '─' "$1")"; }
box_sep()    { printf '├%s┤\n' "$(repeat_char '─' "$1")"; }
box_line()   { printf '│ %-*s │\n' "$(($1 - 2))" "$2"; }

section_header() {
	local title=$1
	local w=60
	printf '\n'
	box_top $w
	box_line $w "${BOLD}${CYAN}$title${RESET}"
	box_bottom $w
}

DB_PATH="${DB_PATH:-$HOME/.local/share/opencode/opencode.db}"
MONTH=""
TOP_N=5
CURRENCY="${CURRENCY:-$}"

DEFAULT_CATEGORY="other"
declare -A CATEGORY_PREFIXES
CATEGORY_NAMES=()
PRETTY=false
SHOW_TODOS=false

INPUT_RATE=""
OUTPUT_RATE=""
REASONING_RATE=""
CACHE_READ_RATE=""
CACHE_WRITE_RATE=""

while [[ $# -gt 0 ]]; do
	case "$1" in
		--db)
			DB_PATH=$2
			shift 2
			;;
		--month)
			MONTH=$2
			shift 2
			;;
		--category)
			if [[ "$2" != *:* ]]; then
				printf 'Invalid --category format. Use NAME:PATH.\n' >&2
				exit 1
			fi
			CATEGORY_NAME=${2%%:*}
			CATEGORY_PATH=${2#*:}
			if [[ -z "$CATEGORY_NAME" || -z "$CATEGORY_PATH" ]]; then
				printf 'Invalid --category format. Use NAME:PATH.\n' >&2
				exit 1
			fi
			add_category_prefix "$CATEGORY_NAME" "$CATEGORY_PATH"
			shift 2
			;;
		--default-category)
			DEFAULT_CATEGORY=$2
			shift 2
			;;
		--top)
			TOP_N=$2
			shift 2
			;;
		--input-rate)
			INPUT_RATE=$2
			shift 2
			;;
		--output-rate)
			OUTPUT_RATE=$2
			shift 2
			;;
		--reasoning-rate)
			REASONING_RATE=$2
			shift 2
			;;
		--cache-read-rate)
			CACHE_READ_RATE=$2
			shift 2
			;;
		--cache-write-rate)
			CACHE_WRITE_RATE=$2
			shift 2
			;;
		--currency)
			CURRENCY=$2
			shift 2
			;;
		--todos)
			SHOW_TODOS=true
			shift
			;;
		--pretty)
			PRETTY=true
			shift
			;;
		--help|-h)
			usage
			exit 0
			;;
		*)
			printf 'Unknown argument: %s\n' "$1" >&2
			usage >&2
			exit 1
			;;
	esac
done

DB_PATH=$(expand_path "$DB_PATH")

if [[ -z "${CATEGORY_NAMES[*]-}" ]]; then
	printf 'At least one --category NAME:PATH is required.\n' >&2
	usage >&2
	exit 1
fi

if [[ -n "$MONTH" ]]; then
	if [[ ! "$MONTH" =~ ^[0-9]{4}-[0-9]{2}$ ]]; then
		printf 'Invalid --month format. Use YYYY-MM.\n' >&2
		exit 1
	fi
	MONTH_START="${MONTH}-01"
	MONTH_END=$(sqlite3 "$DB_PATH" "select date('$MONTH_START','+1 month');")
else
	MONTH_START=$(sqlite3 "$DB_PATH" "select date('now','start of month');")
	MONTH_END=$(sqlite3 "$DB_PATH" "select date('now','start of month','+1 month');")
fi

CATEGORY_WHENS=""
for CATEGORY_NAME in "${CATEGORY_NAMES[@]}"; do
	CATEGORY_CLAUSE=$(category_clause "$CATEGORY_NAME")
	if [[ -n "$CATEGORY_WHENS" ]]; then
		CATEGORY_WHENS+=$'\n\t\t'
	fi
	CATEGORY_WHENS+="when $CATEGORY_CLAUSE then '$(sql_escape "$CATEGORY_NAME")'"
done

if [[ -n "$INPUT_RATE" && -z "$OUTPUT_RATE" ]]; then
	OUTPUT_RATE=$INPUT_RATE
fi
if [[ -n "$INPUT_RATE" && -z "$REASONING_RATE" ]]; then
	REASONING_RATE=$INPUT_RATE
fi

MATERIALIZE_SQL=$(cat <<EOF
create temp table categorized as
with params as (
	select (strftime('%s', '$MONTH_START')*1000) as month_start_ms,
	       (strftime('%s', '$MONTH_END')*1000) as month_end_ms
),
message_filtered as (
	select * from message m, params p
	where m.time_created >= p.month_start_ms and m.time_created < p.month_end_ms
),
session_counts as (
	select m.session_id, count(distinct m.id) as message_count
	from message_filtered m
	group by m.session_id
),
token_totals as (
	select p.session_id,
	       sum(coalesce(json_extract(p.data,'$.tokens.input'),0)) as input_tokens,
	       sum(coalesce(json_extract(p.data,'$.tokens.output'),0)) as output_tokens,
	       sum(coalesce(json_extract(p.data,'$.tokens.reasoning'),0)) as reasoning_tokens,
	       sum(coalesce(json_extract(p.data,'$.tokens.cache.read'),0)) as cache_read_tokens,
	       sum(coalesce(json_extract(p.data,'$.tokens.cache.write'),0)) as cache_write_tokens
	from part p, params pm
	where json_extract(p.data,'$.type')='step-finish'
	  and p.time_created >= pm.month_start_ms and p.time_created < pm.month_end_ms
	group by p.session_id
),
active_sessions as (
	select session_id from session_counts
	union
	select session_id from token_totals
),
combined as (
	select a.session_id,
	       s.project_id,
	       coalesce(sc.message_count,0) as message_count,
	       coalesce(tt.input_tokens,0) as input_tokens,
	       coalesce(tt.output_tokens,0) as output_tokens,
	       coalesce(tt.reasoning_tokens,0) as reasoning_tokens,
	       coalesce(tt.cache_read_tokens,0) as cache_read_tokens,
	       coalesce(tt.cache_write_tokens,0) as cache_write_tokens
	from active_sessions a
	join session s on s.id = a.session_id
	left join session_counts sc on sc.session_id = a.session_id
	left join token_totals tt on tt.session_id = a.session_id
),
with_projects as (
	select c.*, p.worktree, p.name
	from combined c
	join project p on p.id = c.project_id
)
select case
	$CATEGORY_WHENS
	else '$(sql_escape "$DEFAULT_CATEGORY")'
end as bucket,
*
from with_projects;
EOF
)

if [[ "$PRETTY" == true ]]; then
	init_colors
fi

if [[ "$PRETTY" == true ]]; then
	printf '\n'
	box_top 60
	box_line 60 "${BOLD}${CYAN}OpenCode Usage Report${RESET}"
	box_line 60 "${DIM}$MONTH_START to $MONTH_END${RESET}"
	box_bottom 60
else
	printf 'OpenCode usage for %s to %s (exclusive)\n\n' "$MONTH_START" "$MONTH_END"
fi

## --- Single sqlite3 session: materialize the CTE once, then query the temp table ---

# Build the per-bucket top-projects queries
TOP_PROJECT_QUERIES=""
for bucket in "${CATEGORY_NAMES[@]}"; do
	TOP_PROJECT_QUERIES+="
select '---PROJECTS:$(sql_escape "$bucket")';
select worktree || char(9) ||
       count(distinct session_id) || char(9) ||
       sum(message_count) || char(9) ||
       sum(input_tokens+output_tokens+reasoning_tokens)
from categorized
where bucket = '$(sql_escape "$bucket")'
group by worktree
order by sum(input_tokens+output_tokens+reasoning_tokens) desc
limit $TOP_N;
"
done

# Check if the default category needs its own section
BUCKET_PRESENT=false
for bucket in "${CATEGORY_NAMES[@]}"; do
	if [[ "$bucket" == "$DEFAULT_CATEGORY" ]]; then
		BUCKET_PRESENT=true
		break
	fi
done
if [[ "$BUCKET_PRESENT" == false ]]; then
	TOP_PROJECT_QUERIES+="
select '---PROJECTS:$(sql_escape "$DEFAULT_CATEGORY")';
select worktree || char(9) ||
       count(distinct session_id) || char(9) ||
       sum(message_count) || char(9) ||
       sum(input_tokens+output_tokens+reasoning_tokens)
from categorized
where bucket = '$(sql_escape "$DEFAULT_CATEGORY")'
group by worktree
order by sum(input_tokens+output_tokens+reasoning_tokens) desc
limit $TOP_N;
"
fi

# Build cost query if rates are set
COST_QUERY=""
if [[ -n "$INPUT_RATE" || -n "$OUTPUT_RATE" || -n "$REASONING_RATE" || -n "$CACHE_READ_RATE" || -n "$CACHE_WRITE_RATE" ]]; then
	INPUT_RATE=${INPUT_RATE:-0}
	OUTPUT_RATE=${OUTPUT_RATE:-0}
	REASONING_RATE=${REASONING_RATE:-0}
	CACHE_READ_RATE=${CACHE_READ_RATE:-0}
	CACHE_WRITE_RATE=${CACHE_WRITE_RATE:-0}
	COST_QUERY="
select '---COST';
select bucket || char(9) ||
       round((sum(input_tokens) * $INPUT_RATE
            + sum(output_tokens) * $OUTPUT_RATE
            + sum(reasoning_tokens) * $REASONING_RATE
            + sum(cache_read_tokens) * $CACHE_READ_RATE
            + sum(cache_write_tokens) * $CACHE_WRITE_RATE) / 1000000.0, 4)
from categorized
group by bucket
order by bucket;
"
fi

# Build todo stats query if requested
TODO_QUERY=""
if [[ "$SHOW_TODOS" == true ]]; then
	TODO_QUERY="
select '---TODOS_STATUS';
select c.bucket || char(9) ||
       t.status || char(9) ||
       count(*)
from categorized c
join todo t on t.session_id = c.session_id
group by c.bucket, t.status
order by c.bucket, t.status;

select '---TODOS_PRIORITY';
select c.bucket || char(9) ||
       t.priority || char(9) ||
       count(*)
from categorized c
join todo t on t.session_id = c.session_id
group by c.bucket, t.priority
order by c.bucket,
  case t.priority
    when 'critical' then 1
    when 'high' then 2
    when 'medium' then 3
    when 'low' then 4
    else 5
  end;
"
fi

ALL_DATA=$(sqlite3 "$DB_PATH" "
$MATERIALIZE_SQL

select '---OVERVIEW';
select bucket || char(9) ||
       count(distinct session_id) || char(9) ||
       sum(message_count) || char(9) ||
       sum(input_tokens) || char(9) ||
       sum(output_tokens) || char(9) ||
       sum(reasoning_tokens) || char(9) ||
       sum(cache_read_tokens) || char(9) ||
       sum(cache_write_tokens) || char(9) ||
       sum(input_tokens+output_tokens+reasoning_tokens) || char(9) ||
       sum(input_tokens+output_tokens+reasoning_tokens+cache_read_tokens+cache_write_tokens)
from categorized
group by bucket
order by bucket;

select '---PCT';
select bucket || char(9) ||
       round(100.0*sum(input_tokens+output_tokens+reasoning_tokens)
             / nullif(sum(sum(input_tokens+output_tokens+reasoning_tokens)) over (),0), 2) || char(9) ||
       round(100.0*sum(input_tokens+output_tokens+reasoning_tokens+cache_read_tokens+cache_write_tokens)
             / nullif(sum(sum(input_tokens+output_tokens+reasoning_tokens+cache_read_tokens+cache_write_tokens)) over (),0), 2) || char(9) ||
       round(100.0*sum(message_count)
             / nullif(sum(sum(message_count)) over (),0), 2) || char(9) ||
       round(100.0*count(distinct session_id)
             / nullif(sum(count(distinct session_id)) over (),0), 2)
from categorized
group by bucket
order by bucket;

$TOP_PROJECT_QUERIES

select '---SUMMARY';
select bucket || char(9) ||
       round(100.0*sum(input_tokens+output_tokens+reasoning_tokens)
             / nullif(sum(sum(input_tokens+output_tokens+reasoning_tokens)) over (),0), 1) || char(9) ||
       round(100.0*sum(message_count)
             / nullif(sum(sum(message_count)) over (),0), 1) || char(9) ||
       sum(message_count) || char(9) ||
       sum(input_tokens+output_tokens+reasoning_tokens)
from categorized
group by bucket
order by sum(input_tokens+output_tokens+reasoning_tokens) desc;

$COST_QUERY

$TODO_QUERY
")

## --- Parse the combined output into sections ---

OVERVIEW_DATA=""
PCT_DATA=""
SUMMARY_DATA=""
COST_DATA=""
TODOS_STATUS_DATA=""
TODOS_PRIORITY_DATA=""
declare -A PROJECT_DATA_MAP
CURRENT_SECTION=""

while IFS= read -r line; do
	case "$line" in
		---OVERVIEW) CURRENT_SECTION="overview"; continue ;;
		---PCT) CURRENT_SECTION="pct"; continue ;;
		---PROJECTS:*) CURRENT_SECTION="projects:${line#---PROJECTS:}"; continue ;;
		---SUMMARY) CURRENT_SECTION="summary"; continue ;;
		---COST) CURRENT_SECTION="cost"; continue ;;
		---TODOS_STATUS) CURRENT_SECTION="todos_status"; continue ;;
		---TODOS_PRIORITY) CURRENT_SECTION="todos_priority"; continue ;;
	esac
	case "$CURRENT_SECTION" in
		overview)
			[[ -n "$OVERVIEW_DATA" ]] && OVERVIEW_DATA+=$'\n'
			OVERVIEW_DATA+="$line"
			;;
		pct)
			[[ -n "$PCT_DATA" ]] && PCT_DATA+=$'\n'
			PCT_DATA+="$line"
			;;
		projects:*)
			local_bucket=${CURRENT_SECTION#projects:}
			if [[ -n "${PROJECT_DATA_MAP[$local_bucket]+x}" ]]; then
				PROJECT_DATA_MAP[$local_bucket]+=$'\n'
			fi
			PROJECT_DATA_MAP[$local_bucket]+="$line"
			;;
		summary)
			[[ -n "$SUMMARY_DATA" ]] && SUMMARY_DATA+=$'\n'
			SUMMARY_DATA+="$line"
			;;
		cost)
			[[ -n "$COST_DATA" ]] && COST_DATA+=$'\n'
			COST_DATA+="$line"
			;;
		todos_status)
			[[ -n "$TODOS_STATUS_DATA" ]] && TODOS_STATUS_DATA+=$'\n'
			TODOS_STATUS_DATA+="$line"
			;;
		todos_priority)
			[[ -n "$TODOS_PRIORITY_DATA" ]] && TODOS_PRIORITY_DATA+=$'\n'
			TODOS_PRIORITY_DATA+="$line"
			;;
	esac
done <<< "$ALL_DATA"

## --- Render output ---

if [[ "$PRETTY" == true ]]; then
	section_header "Overview"
	printf '\n'
	printf '  %-14s %10s %10s %18s %18s\n' \
		"${BOLD}Category${RESET}" "${BOLD}Sessions${RESET}" "${BOLD}Messages${RESET}" "${BOLD}Tokens${RESET}" "${BOLD}Tokens+Cache${RESET}"
	printf '  %-14s %10s %10s %18s %18s\n' \
		"──────────────" "──────────" "──────────" "──────────────────" "──────────────────"
	while IFS=$'\t' read -r bucket sessions messages _in _out _reason _cread _cwrite total total_cache; do
		printf '  %-14s %10s %10s %18s %18s\n' \
			"$bucket" "$(format_number "$sessions")" "$(format_number "$messages")" \
			"$(format_number "$total")" "$(format_number "$total_cache")"
	done <<< "$OVERVIEW_DATA"

	section_header "Usage Split"
	while IFS=$'\t' read -r bucket pct_tokens _pct_cache pct_msgs pct_sess; do
		printf '\n  %s%-14s%s\n' "$BOLD" "$bucket" "$RESET"
		printf '  Tokens   %s %6s%%\n' "$(make_bar "$pct_tokens")" "$pct_tokens"
		printf '  Messages %s %6s%%\n' "$(make_bar "$pct_msgs")" "$pct_msgs"
		printf '  Sessions %s %6s%%\n' "$(make_bar "$pct_sess")" "$pct_sess"
	done <<< "$PCT_DATA"
else
	printf '%s\n' "$OVERVIEW_DATA" | (
		printf 'bucket\tsessions\tmessages\tinput_tokens\toutput_tokens\treasoning_tokens\tcache_read_tokens\tcache_write_tokens\ttotal_tokens_no_cache\ttotal_tokens_with_cache\n'
		cat
	) | format_table

	printf '\nPercent split\n'
	printf '%s\n' "$PCT_DATA" | (
		printf 'bucket\tpct_tokens_no_cache\tpct_tokens_with_cache\tpct_messages\tpct_sessions\n'
		cat
	) | format_table
fi

BUCKETS=("${CATEGORY_NAMES[@]}")
if [[ "$BUCKET_PRESENT" == false ]]; then
	BUCKETS+=("$DEFAULT_CATEGORY")
fi

if [[ "$PRETTY" == true ]]; then
	section_header "Top Projects"
else
	printf '\nTop projects by tokens (no cache)\n'
fi

for bucket in "${BUCKETS[@]}"; do
	PROJECT_DATA="${PROJECT_DATA_MAP[$bucket]-}"
	if [[ "$PRETTY" == true ]]; then
		printf '\n  %s%s%s\n' "$BOLD" "$bucket" "$RESET"
		if [[ -z "$PROJECT_DATA" ]]; then
			printf '  %s(no data)%s\n' "$DIM" "$RESET"
			continue
		fi
		printf '  %-45s %10s %10s %18s\n' \
			"${DIM}Path${RESET}" "${DIM}Sessions${RESET}" "${DIM}Messages${RESET}" "${DIM}Tokens${RESET}"
		while IFS=$'\t' read -r worktree sessions messages tokens; do
			local_path=${worktree/#$HOME/\~}
			printf '  %-45s %10s %10s %18s\n' \
				"$local_path" "$(format_number "$sessions")" "$(format_number "$messages")" "$(format_number "$tokens")"
		done <<< "$PROJECT_DATA"
	else
		printf '\n%s\n' "$bucket"
		if [[ -n "$PROJECT_DATA" ]]; then
			printf '%s\n' "$PROJECT_DATA" | (
				printf 'worktree\tsessions\tmessages\ttotal_tokens_no_cache\n'
				cat
			) | format_table
		fi
	fi
done

if [[ "$PRETTY" == true ]]; then
	section_header "Summary"
	printf '\n'
	while IFS=$'\t' read -r bucket pct_tokens pct_msgs messages tokens; do
		printf '  %s%-14s%s  %s%% tokens  |  %s%% messages  |  %s msgs  |  %s tokens\n' \
			"$BOLD" "$bucket" "$RESET" \
			"$pct_tokens" "$pct_msgs" \
			"$(format_number "$messages")" "$(format_number "$tokens")"
	done <<< "$SUMMARY_DATA"
	printf '\n'
else
	printf '\n--- Summary ---\n'
	while IFS=$'\t' read -r bucket pct_tokens pct_msgs messages tokens; do
		printf '%s: %s%% tokens, %s%% messages (%s messages, %s tokens)\n' \
			"$bucket" "$pct_tokens" "$pct_msgs" "$messages" "$tokens"
	done <<< "$SUMMARY_DATA"
fi

if [[ -n "$COST_DATA" ]]; then
	if [[ "$PRETTY" == true ]]; then
		section_header "Cost Estimate (${CURRENCY} per 1M tokens)"
		printf '\n'
		while IFS=$'\t' read -r bucket cost; do
			printf '  %-14s %s%s\n' "$bucket" "$CURRENCY" "$cost"
		done <<< "$COST_DATA"
		printf '\n'
	else
		printf '\nCost estimate (%s per 1M tokens)\n' "$CURRENCY"
		printf '%s\n' "$COST_DATA" | (
			printf 'bucket\tcost\n'
			cat
		) | format_table
	fi
fi

if [[ -n "$TODOS_STATUS_DATA" ]]; then
	# Build a map: bucket -> {status: count, ...}
	declare -A TODO_STATUS_MAP
	ALL_STATUSES=()
	declare -A STATUS_SEEN

	while IFS=$'\t' read -r bucket status count; do
		TODO_STATUS_MAP["$bucket|$status"]=$count
		if [[ -z "${STATUS_SEEN[$status]+x}" ]]; then
			STATUS_SEEN[$status]=1
			ALL_STATUSES+=("$status")
		fi
	done <<< "$TODOS_STATUS_DATA"

	if [[ "$PRETTY" == true ]]; then
		section_header "Todo Status by Category"
		printf '\n'
		# Header
		local_fmt="  %-14s"
		printf "$local_fmt" "${BOLD}Category${RESET}"
		for s in "${ALL_STATUSES[@]}"; do
			printf ' %12s' "${BOLD}${s}${RESET}"
		done
		printf ' %12s\n' "${BOLD}total${RESET}"
		printf "$local_fmt" "──────────────"
		for s in "${ALL_STATUSES[@]}"; do
			printf ' %12s' "────────────"
		done
		printf ' %12s\n' "────────────"

		for bucket in "${BUCKETS[@]}"; do
			printf "$local_fmt" "$bucket"
			local_total=0
			for s in "${ALL_STATUSES[@]}"; do
				local_val=${TODO_STATUS_MAP["$bucket|$s"]:-0}
				printf ' %12s' "$(format_number "$local_val")"
				(( local_total += local_val ))
			done
			printf ' %12s\n' "$(format_number "$local_total")"
		done

		# Completion rate
		printf '\n'
		for bucket in "${BUCKETS[@]}"; do
			local_completed=${TODO_STATUS_MAP["$bucket|completed"]:-0}
			local_total=0
			for s in "${ALL_STATUSES[@]}"; do
				(( local_total += ${TODO_STATUS_MAP["$bucket|$s"]:-0} ))
			done
			if (( local_total > 0 )); then
				local_pct=$(( local_completed * 100 / local_total ))
				printf '  %-14s completion: %s %d%%\n' "$bucket" "$(make_bar "$local_pct")" "$local_pct"
			fi
		done
		printf '\n'
	else
		printf '\nTodo status by category\n'
		printf '%s\n' "$TODOS_STATUS_DATA" | (
			printf 'bucket\tstatus\tcount\n'
			cat
		) | format_table
	fi
fi

if [[ -n "$TODOS_PRIORITY_DATA" ]]; then
	if [[ "$PRETTY" == true ]]; then
		section_header "Todo Priority by Category"
		printf '\n'

		declare -A TODO_PRIORITY_MAP
		ALL_PRIORITIES=()
		declare -A PRIORITY_SEEN

		while IFS=$'\t' read -r bucket priority count; do
			TODO_PRIORITY_MAP["$bucket|$priority"]=$count
			if [[ -z "${PRIORITY_SEEN[$priority]+x}" ]]; then
				PRIORITY_SEEN[$priority]=1
				ALL_PRIORITIES+=("$priority")
			fi
		done <<< "$TODOS_PRIORITY_DATA"

		local_fmt="  %-14s"
		printf "$local_fmt" "${BOLD}Category${RESET}"
		for p in "${ALL_PRIORITIES[@]}"; do
			printf ' %10s' "${BOLD}${p}${RESET}"
		done
		printf '\n'
		printf "$local_fmt" "──────────────"
		for p in "${ALL_PRIORITIES[@]}"; do
			printf ' %10s' "──────────"
		done
		printf '\n'

		for bucket in "${BUCKETS[@]}"; do
			printf "$local_fmt" "$bucket"
			for p in "${ALL_PRIORITIES[@]}"; do
				local_val=${TODO_PRIORITY_MAP["$bucket|$p"]:-0}
				printf ' %10s' "$(format_number "$local_val")"
			done
			printf '\n'
		done
		printf '\n'
	else
		printf '\nTodo priority by category\n'
		printf '%s\n' "$TODOS_PRIORITY_DATA" | (
			printf 'bucket\tpriority\tcount\n'
			cat
		) | format_table
	fi
fi
